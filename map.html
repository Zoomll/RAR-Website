<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive SVG Map with Zoom and Pan</title>
    <style>
        #svgContainer {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            border: 1px solid black;
            position: relative;
            touch-action: none; /* Disable default touch actions for smoother panning */
        }
        #svgImage {
            width: 100%;
            height: 100%;
        }
        #zoomValue {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <span id="zoomValue">1</span>
    <div id="svgContainer">
        <svg id="svgImage" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 1000" preserveAspectRatio="xMidYMid meet">
            <image href="TheRobloxianArchipelagoMapV1.svg" width="2000" height="1000" />
        </svg>
    </div>

    <script>
        const svgImage = document.getElementById("svgImage");
        const svgContainer = document.getElementById("svgContainer");
        const zoomValue = document.getElementById("zoomValue");

        let viewBox = { x: 0, y: 0, w: svgImage.clientWidth, h: svgImage.clientHeight };
        svgImage.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
        const svgSize = { w: svgImage.clientWidth, h: svgImage.clientHeight };
        let isPanning = false;
        let startPoint = { x: 0, y: 0 };
        let scale = 1;

        // Mousewheel Zooming
        svgContainer.onwheel = function (e) {
            e.preventDefault();
            const zoomFactor = 0.1; // Zoom factor
            let w = viewBox.w;
            let h = viewBox.h;
            let mx = e.offsetX;
            let my = e.offsetY;
            
            // Calculate zoom step
            let dw = w * zoomFactor * (e.deltaY > 0 ? -1 : 1);
            let dh = h * zoomFactor * (e.deltaY > 0 ? -1 : 1);
            
            // Calculate new viewBox
            let dx = dw * mx / svgSize.w;
            let dy = dh * my / svgSize.h;
            viewBox = {
                x: viewBox.x + dx,
                y: viewBox.y + dy,
                w: viewBox.w - dw,
                h: viewBox.h - dh
            };

            scale = svgSize.w / viewBox.w;
            svgImage.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            zoomValue.innerText = `${Math.round(scale * 100) / 100}`;
        };

        // Mouse Dragging for Panning
        svgContainer.onmousedown = function (e) {
            isPanning = true;
            startPoint = { x: e.clientX, y: e.clientY };
        };

        svgContainer.onmousemove = function (e) {
            if (isPanning) {
                let dx = (startPoint.x - e.clientX) / scale;
                let dy = (startPoint.y - e.clientY) / scale;

                // Update viewBox as we pan
                viewBox = {
                    x: viewBox.x + dx,
                    y: viewBox.y + dy,
                    w: viewBox.w,
                    h: viewBox.h
                };

                svgImage.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                startPoint = { x: e.clientX, y: e.clientY };
            }
        };

        svgContainer.onmouseup = function () {
            isPanning = false;
        };

        svgContainer.onmouseleave = function () {
            isPanning = false;
        };

        // Mobile Touch Support
        let touchStart = [];
        svgContainer.ontouchstart = function (e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                touchStart = [e.touches[0], e.touches[1]];
            }
        };

        svgContainer.ontouchmove = function (e) {
            if (e.touches.length === 2) {
                e.preventDefault();

                const [firstTouch, secondTouch] = e.touches;
                const currentDist = Math.hypot(secondTouch.pageX - firstTouch.pageX, secondTouch.pageY - firstTouch.pageY);
                const startDist = Math.hypot(touchStart[1].pageX - touchStart[0].pageX, touchStart[1].pageY - touchStart[0].pageY);

                const pinchZoomFactor = currentDist / startDist;

                // Calculate new viewbox based on pinch zoom factor
                let dw = (viewBox.w - viewBox.w * pinchZoomFactor) * 0.5;
                let dh = (viewBox.h - viewBox.h * pinchZoomFactor) * 0.5;

                viewBox.x += dw;
                viewBox.y += dh;
                viewBox.w -= 2 * dw;
                viewBox.h -= 2 * dh;

                scale = svgSize.w / viewBox.w;
                svgImage.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);

                // Update for next touch move
                touchStart = [firstTouch, secondTouch];
            }
        };
    </script>
</body>
</html>
