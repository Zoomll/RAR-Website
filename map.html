<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive SVG Map with Zoom and Pan (Desktop + Mobile)</title>
    <style>
        #svgContainer {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            border: 1px solid black;
            position: relative;
            touch-action: none; /* Disable default touch actions */
        }
        #svgImage {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="svgContainer">
        <!-- Replace this SVG link with your actual Robloxian Archipelago Map -->
        <svg id="svgImage" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 1000" preserveAspectRatio="xMidYMid meet">
            <!-- Your Robloxian Archipelago Map should be included here -->
            <image href="TheRobloxianArchipelagoMapV1.svg" width="2000" height="1000" />
        </svg>
    </div>

    <script>
        const svgImage = document.getElementById("svgImage");
        const svgContainer = document.getElementById("svgContainer");

        let viewBox = { x: 0, y: 0, w: 2000, h: 1000 }; // Initial viewBox matching SVG dimensions
        svgImage.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);

        const svgSize = { w: svgImage.clientWidth, h: svgImage.clientHeight };
        let isPanning = false;
        let startPoint = { x: 0, y: 0 };
        let currentTranslate = { x: 0, y: 0 };
        let scale = 1;
        let initialPinchDistance = null;
        let lastTouchCenter = null;

        // Helper function to sync viewBox after zoom or pan
        function syncViewBox() {
            svgImage.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            currentTranslate = { x: viewBox.x, y: viewBox.y };
            scale = svgSize.w / viewBox.w;
        }

        // Desktop: Mouse Wheel Zooming (Inverted to zoom correctly)
        svgContainer.onmousewheel = function (e) {
            e.preventDefault();
            const w = viewBox.w;
            const h = viewBox.h;
            const mx = e.offsetX; // Mouse x relative to the container
            const my = e.offsetY; // Mouse y relative to the container

            const dw = -w * Math.sign(e.deltaY) * 0.1; // Inverted zoom factor
            const dh = -h * Math.sign(e.deltaY) * 0.1;

            const dx = (dw * mx) / svgSize.w;
            const dy = (dh * my) / svgSize.h;

            viewBox = {
                x: viewBox.x + dx,
                y: viewBox.y + dy,
                w: viewBox.w - dw,
                h: viewBox.h - dh
            };

            syncViewBox();
        };

        // Desktop: Mouse Dragging for Panning
        svgContainer.onmousedown = function (e) {
            isPanning = true;
            startPoint = { x: e.x, y: e.y };
            currentTranslate = { x: viewBox.x, y: viewBox.y }; // Store current viewBox position
        };

        svgContainer.onmousemove = function (e) {
            if (isPanning) {
                const dx = (startPoint.x - e.x) / scale;
                const dy = (startPoint.y - e.y) / scale;
                viewBox = {
                    x: currentTranslate.x + dx,
                    y: currentTranslate.y + dy,
                    w: viewBox.w,
                    h: viewBox.h
                };
                syncViewBox();
            }
        };

        svgContainer.onmouseup = function () {
            isPanning = false;
        };

        svgContainer.onmouseleave = function () {
            isPanning = false;
        };

        // Mobile: Touch Zooming & Panning
        svgContainer.ontouchstart = function (e) {
            if (e.touches.length === 2) {
                initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                lastTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
            } else if (e.touches.length === 1) {
                startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                currentTranslate = { x: viewBox.x, y: viewBox.y }; // Store current viewBox position
            }
        };

        svgContainer.ontouchmove = function (e) {
            e.preventDefault();
            if (e.touches.length === 2 && initialPinchDistance) {
                const newPinchDistance = getDistance(e.touches[0], e.touches[1]);
                const pinchRatio = initialPinchDistance / newPinchDistance;
                const center = getTouchCenter(e.touches[0], e.touches[1]);

                const dw = viewBox.w * (1 - pinchRatio); // Inverted zoom factor for mobile
                const dh = viewBox.h * (1 - pinchRatio);

                const dx = (dw * center.x) / svgSize.w;
                const dy = (dh * center.y) / svgSize.h;

                viewBox = {
                    x: viewBox.x + dx,
                    y: viewBox.y + dy,
                    w: viewBox.w - dw,
                    h: viewBox.h - dh
                };

                initialPinchDistance = newPinchDistance;
                syncViewBox();
            } else if (e.touches.length === 1) {
                const dx = (startPoint.x - e.touches[0].clientX) / scale;
                const dy = (startPoint.y - e.touches[0].clientY) / scale;
                viewBox = {
                    x: currentTranslate.x + dx,
                    y: currentTranslate.y + dy,
                    w: viewBox.w,
                    h: viewBox.h
                };
                syncViewBox();
            }
        };

        svgContainer.ontouchend = function () {
            initialPinchDistance = null;
            lastTouchCenter = null;
            currentTranslate = { x: viewBox.x, y: viewBox.y };
        };

        function getDistance(touch1, touch2) {
            return Math.sqrt(Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2));
        }

        function getTouchCenter(touch1, touch2) {
            return {
                x: (touch1.clientX + touch2.clientX) / 2,
                y: (touch1.clientY + touch2.clientY) / 2
            };
        }
    </script>
</body>
</html>
